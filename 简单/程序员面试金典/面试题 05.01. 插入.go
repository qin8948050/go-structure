/* 给定两个整型数字 N 与 M，以及表示比特位置的 i 与 j（i <= j，且从 0 位开始计算）。

编写一种方法，使 M 对应的二进制数字插入 N 对应的二进制数字的第 i ~ j 位区域，不足之处用 0 补齐。具体插入过程如图所示。



题目保证从 i 位到 j 位足以容纳 M， 例如： M = 10011，则 i～j 区域至少可容纳 5 位。

 

示例1:

 输入：N = 1024(10000000000), M = 19(10011), i = 2, j = 6
 输出：N = 1100(10001001100)
示例2:

 输入： N = 0, M = 31(11111), i = 0, j = 4
 输出：N = 31(11111)
 */

 /*
 解题思路：
N: 11111111(255)
M: 0101(5)
i: 3
j: 6
把 M 插入 N 的第6位到第3位，得到的结果应该是 10101111(175)。要想得到这个结果应该做三步

将 N 的 第j位 到 第i位 置位 0。11111111 -> 10000111
将 M 左移i位。0101 -> 00101000
将上述两个值做或计算。 10000111 | 00101000 = 10101111
这三个步里第一步 "将 N 的 第j位 到 第i位 置位 0" 是比费劲的。可以分为三步：

首先可以将 N 的 第j+1位到最高位保持不变，第0 到 第j位 设为0。 具体做法是 N 先右移j+1， 再左移 j+1。得到 nj

nj := N >> (j+1) << (j+1)
10000000 = 11111111 >> 7 << 7
其次将 第i位到最高位 设为0， 其余位保持不变。具体做法是 N 先右移 i 在左移 i, 此时 N 的 0 到 第i 位都变成了0。然后在和 N 做异或操作，得到 ni

ni := N >> i << i ^ N
00000111 = 11111111 >> 3 << 3 ^ 11111111
         = 11111000 ^ 11111111
第三步将上述两步骤得到的 ni, nj 做 或操作，就可以得到 N 的 第i位 到 第j位 为0的 nz

nz = nj | ni
10000111 = 10000000 | 00000111
将 M 左移i位, 可以将 M(原来的M值) 对应到 N 的 第j到第j位。


mi := M << i
00101000 = 0101 << 3
将 mi 和 nz 做或操作即可得到结果


res := mi | nz
10101111 = 00101000 | 10000111
  */

func insertBits(N int, M int, i int, j int) int {
	J:=N >>uint(j+1) <<uint(j+1)
	I:=N >>uint(i) <<uint(i) ^ N
	z:=J | i
	return z | M << uint(i)
}